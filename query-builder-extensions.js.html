<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.4.0">
  <meta charset="utf-8">
  <title>Source: query-builder-extensions.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: query-builder-extensions.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>&#x27;use strict&#x27;

/** @module extensions */

var asArray &#x3D; require(&#x27;./utils.js&#x27;).asArray

/**
 * Builds a {@link http://docs.marklogic.com/guide/rest-dev/search#id_69918 combined query}
 *
 * @static
 * @param {Object} query - a structured query (from {@link MLQueryBuilder#where})
 * @param {String} [qtext] - a query text string, to be parsed server-side
 * @param {Object} [options] - search options
 * @return {Object} {@link http://docs.marklogic.com/guide/rest-dev/search#id_69918 combined query}
 */
function combined (query, qtext, options) {
  if (!options &amp;amp;&amp;amp; qtext &amp;amp;&amp;amp; typeof qtext !&#x3D;&#x3D; &#x27;string&#x27;) {
    options &#x3D; qtext
    qtext &#x3D; null
  }

  return {
    search: {
      query: query &amp;amp;&amp;amp; query.query || query,
      qtext: qtext || &#x27;&#x27;,
      options: options &amp;amp;&amp;amp; options.options || options
    }
  }
}

/**
 * Builds a {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_38268 &#x60;range-constraint-query&#x60;}
 *
 * @static
 * @param {String} name - constraint name
 * @param {String} [operator] - operator for matching constraint to &#x60;values&#x60;; one of &#x60;LT&#x60;, &#x60;LE&#x60;, &#x60;GT&#x60;, &#x60;GE&#x60;, &#x60;EQ&#x60;, &#x60;NE&#x60; (defaults to &#x60;EQ&#x60;)
 * @param {String|Array&amp;lt;String&gt;} values - the values the constraint should equal (logical OR)
 * @param {String|Array&amp;lt;String&gt;} [options] - range options: {@link http://docs.marklogic.com/guide/rest-dev/appendixa#id_84264}
 * @return {Object} {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_38268 range-constraint-query}
 */
function rangeConstraint (name, operator, values, options) {
  if (!values &amp;amp;&amp;amp; !options) {
    values &#x3D; operator
    operator &#x3D; null
  }

  // TODO: use comparisons from qb.range

  if (operator &amp;amp;&amp;amp; [&#x27;LT&#x27;, &#x27;LE&#x27;, &#x27;GT&#x27;, &#x27;GE&#x27;, &#x27;EQ&#x27;, &#x27;NE&#x27;].indexOf(operator) &#x3D;&#x3D;&#x3D; -1) {
    throw new TypeError(&#x27;invalid rangeConstraint query operator: &#x27; + operator)
  }

  return {
    &#x27;range-constraint-query&#x27;: {
      &#x27;constraint-name&#x27;: name,
      &#x27;range-operator&#x27;: operator || &#x27;EQ&#x27;,
      &#x27;value&#x27;: asArray(values),
      &#x27;range-option&#x27;: asArray(options)
    }
  }
}

/**
 * Builds a {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_63420 &#x60;value-constraint-query&#x60;}
 *
 * @static
 * @param {String} name - constraint name
 * @param {String|Number|Array&amp;lt;String&gt;|Array&amp;lt;Number&gt;|null} values - the values the constraint should equal (logical OR)
 * @return {Object} {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_63420 value-constraint-query}
 */
function valueConstraint (name, values) {
  var query &#x3D; {
    &#x27;value-constraint-query&#x27;: {
      &#x27;constraint-name&#x27;: name
    }
  }

  var type

  if (values &#x3D;&#x3D;&#x3D; null) {
    type &#x3D; &#x27;null&#x27;
    values &#x3D; []
  } else {
    values &#x3D; asArray(values)
    type &#x3D; typeof values[0]
    type &#x3D; ((type &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) &amp;amp;&amp;amp; &#x27;text&#x27;) || type
  }

  query[&#x27;value-constraint-query&#x27;][type] &#x3D; values

  return query
}

/**
 * Builds a {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_66833 &#x60;word-constraint-query&#x60;}
 *
 * @static
 * @param {String} name - constraint name
 * @param {String|Array&amp;lt;String&gt;} values - the values the constraint should equal (logical OR)
 * @return {Object} {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_66833 word-constraint-query}
 */
function wordConstraint (name, values) {
  return {
    &#x27;word-constraint-query&#x27;: {
      &#x27;constraint-name&#x27;: name,
      &#x27;text&#x27;: asArray(values)
    }
  }
}

/**
 * Builds a {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_30776 &#x60;collection-constraint-query&#x60;}
 *
 * @static
 * @param {String} name - constraint name
 * @param {String|Array&amp;lt;String&gt;} values - the values the constraint should equal (logical OR)
 * @return {Object} {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_30776 collection-constraint-query}
 */
function collectionConstraint (name, values) {
  return {
    &#x27;collection-constraint-query&#x27;: {
      &#x27;constraint-name&#x27;: name,
      &#x27;uri&#x27;: asArray(values)
    }
  }
}

/**
 * Builds a {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_28778 &#x60;custom-constraint-query&#x60;}
 *
 * @static
 * @param {String} name - constraint name
 * @param {...String|Array&amp;lt;String&gt;|Array&amp;lt;Object&gt;} values - the values the constraint should equal (logical OR)
 * @return {Object} {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_28778 custom-constraint-query}
 */
function customConstraint () {
  var args &#x3D; asArray.apply(null, arguments)

  var constraintName &#x3D; args.shift()

  // horrible hack for when arguments.length &#x3D;&#x3D;&#x3D; 2 and arguments[1] is an array
  if (args.length &#x3D;&#x3D;&#x3D; 1 &amp;amp;&amp;amp; Array.isArray(args[0])) {
    args &#x3D; args[0]
  }

  // args instanceof Array&amp;lt;Object&gt;
  var shouldExtend &#x3D; args.map(function (arg) {
    return arg &amp;amp;&amp;amp; typeof arg &#x3D;&#x3D;&#x3D; &#x27;object&#x27;
  })
  .reduce(function (a, b) {
    return a &amp;amp;&amp;amp; b
  })

  var query &#x3D; {
    &#x27;custom-constraint-query&#x27;: {
      &#x27;constraint-name&#x27;: constraintName
    }
  }

  if (shouldExtend) {
    while (args.length) {
      Object.assign(query[&#x27;custom-constraint-query&#x27;], args.shift())
    }
  } else {
    query[&#x27;custom-constraint-query&#x27;].text &#x3D; args.filter(function (arg) {
      return !(arg &amp;amp;&amp;amp; typeof arg &#x3D;&#x3D;&#x3D; &#x27;object&#x27;)
    })
  }

  return query
}

/**
 * Helper method: builds an object of &#x60;points&#x60;, &#x60;boxes&#x60;, &#x60;circles&#x60;, and &#x60;polygons&#x60;,
 * used by {@link MLQueryBuilder.ext.geospatialConstraint}, for use with
 * {@link MLQueryBuilder.ext.customConstraint}
 *
 * examples:
 *
 *   &#x60;&#x60;&#x60;
 *   qb.ext.geospatialConstraint(&#x27;name&#x27;,
 *     { latitude: 1, longitude: 2 },
 *     { south: 1, west: 2, north: 3, east: 4 }
 *   )
 *   &#x60;&#x60;&#x60;
 *
 *   &#x60;&#x60;&#x60;
 *   qb.ext.customConstraint(&#x27;name&#x27;, qb.ext.geospatialValues(
 *     { latitude: 1, longitude: 2 },
 *     { south: 1, west: 2, north: 3, east: 4 }
 *   ))
 *   &#x60;&#x60;&#x60;
 *
 * @static
 * @param {...Object} values - the geospatial values to parse
 * @return {Object} parsed geospatial values
 */
function geospatialValues () {
  var shapes &#x3D; asArray.apply(null, arguments)

  var points &#x3D; []
  var boxes &#x3D; []
  var circles &#x3D; []
  var polygons &#x3D; []
  var shape

  for (var i &#x3D; 0; i &amp;lt; shapes.length; i++) {
    shape &#x3D; shapes[i]

    if (shape.latitude) {
      points.push(shape)
    } else if (shape.south) {
      boxes.push(shape)
    } else if (shape.radius) {
      circles.push(shape)
    } else if (shape.point) {
      polygons.push(shape)
    }
  }

  return {
    point: points,
    box: boxes,
    circle: circles,
    polygon: polygons
  }
}

/**
 * Builds a {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_88775 &#x60;geospatial-constraint-query&#x60;}
 *
 * @static
 * @param {String} name - constraint name
 * @param {...Object} values - the geospatial values to parse
 * @return {Object} [geospatial-constraint-query](http://docs.marklogic.com/guide/search-dev/structured-query#id_88775)
 */
function geospatialConstraint () {
  var args &#x3D; asArray.apply(null, arguments)

  var constraintName &#x3D; args.shift()

  // horrible hack for when arguments.length &#x3D;&#x3D;&#x3D; 2 and arguments[1] is an array
  if (args.length &#x3D;&#x3D;&#x3D; 1 &amp;amp;&amp;amp; Array.isArray(args[0])) {
    args &#x3D; args[0]
  }

  var geoValues &#x3D; this.geospatialValues.apply(this, args)

  var query &#x3D; {
    &#x27;geospatial-constraint-query&#x27;: {
      &#x27;constraint-name&#x27;: constraintName
    }
  }

  Object.assign(query[&#x27;geospatial-constraint-query&#x27;], geoValues)

  return query
}

/**
 * constraint query function factory
 *
 * @static
 * @param {String} type - constraint type (&#x60;&#x27;value&#x27; || &#x27;word&#x27; || collection&#x27; || &#x27;custom&#x27; || &#x27;*&#x27;&#x60;)
 * @return {Function} a constraint query builder function, one of:
 *   - {@link MLQueryBuilder.ext.rangeConstraint}
 *   - {@link MLQueryBuilder.ext.valueConstraint}
 *   - {@link MLQueryBuilder.ext.wordConstraint}
 *   - {@link MLQueryBuilder.ext.collectionConstraint}
 *   - {@link MLQueryBuilder.ext.customConstraint}
 */
function constraint (type) {
  switch (type) {
    case &#x27;value&#x27;:
      return this.valueConstraint
    case &#x27;word&#x27;:
      return this.wordConstraint
    case &#x27;custom&#x27;:
      return this.customConstraint
    case &#x27;collection&#x27;:
      return this.collectionConstraint
    default:
      return this.rangeConstraint
  }
}

/**
 * Builds an {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_45570 &#x60;operator-state&#x60; query component}
 *
 * @static
 * @param {String} name - operator name
 * @param {String} stateName - operator-state name
 * @return {Object} {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_45570 operator-state query component}
 */
function operatorState (name, stateName) {
  return {
    &#x27;operator-state&#x27;: {
      &#x27;operator-name&#x27;: name,
      &#x27;state-name&#x27;: stateName
    }
  }
}

module.exports &#x3D; {
  combined: combined,
  rangeConstraint: rangeConstraint,
  valueConstraint: valueConstraint,
  wordConstraint: wordConstraint,
  collectionConstraint: collectionConstraint,
  customConstraint: customConstraint,
  geospatialValues: geospatialValues,
  geospatialConstraint: geospatialConstraint,
  constraint: constraint,
  operatorState: operatorState
}
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.4.0 on May 27, 2016.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>